# 프로그라피 과제 수행 (Table Tennis)

### ✨ 구현 기능 명세

1. 공통 API Response

- [X] 요청이 성공했을 때, code = 200, message = "API 요청이 성공했습니다." 를 반환합니다.
- [X] 잘못된 API 요청은 code = 201, message = "불가능한 요청입니다." 를 반환합니다.
- [X] 서버 에러가 발생하는 케이스는 code = 500, message = "에러가 발생했습니다." 를 반환합니다.
- [X] result가 존재하지 않을 때는, code와 message만 출력합니다.

2. 헬스체크 API

- [X] 정상적인 서버 상태일 경우, code = 200, message = "API 요청이 성공했습니다." 를 반환합니다.

3. 초기화 API

- [X] 기존에 존재하는 테이블의 모든 컬럼을 우선 삭제합니다.
- [X] Seed, Quantity에 맞춰 Faker API 응답 결과를 파싱합니다.
- [X] Faker 응답 결과는 다음 원칙에 맞춰 User로 변경합니다.
    - [X] 응답 값의 id필드는 fakerId로 저장합니다.
    - [X] 응답 값의 id(fakerId)를 오름차순으로 정렬하여 데이터를 저장합니다.
    - [X] username 필드는 name으로 저장합니다.
    - [X] email 필드는 그대로 저장합니다.
    - [X] 응답 값의 id(fakerId) 값이 30 이하의 회원은 활성(ACTIVE) 상태로 세팅합니다.
    - [X] 응답 값의 id(fakerId) 값이 31 이상, 60 이하의 회원은 대기(WAIT) 상태로 세팅합니다.
    - [X] 응답 값의 id(fakerId) 값이 61 이상인 회원은 비활성(NON_ACTIVE) 상태로 세팅합니다.
- [X] 데이터가 저장되는 시점에 따라 createdAt과 updatedAt을 저장합니다.

4. 유저 전체 조회 API

- [X] 유저의 모든 회원정보를 id 오름차순 기준으로 페이징에 맞춰 조회합니다.

5. 방 생성 API

- [X] 방 정보는 RequestBody에 담아 요청합니다.
- [X] 다음과 같은 조건을 모두 만족하는 경우 저장이 가능합니다
    - [X] User의 Status는 ACTIVE이다.
    - [X] User는 어떤 방에도 속해 있지 않다.
- [X] 조건을 만족하지 않는 경우, 201 응답을 반환합니다.
- [X] 데이터가 저장되는 시점에 따라 createdAt과 updatedAt을 저장합니다.

6. 방 전체 조회 API

- [X] 방의 정보를 id 오름차순 기준으로 페이징에 맞춰 조회합니다

7. 방 상세 조회 API

- [X] 특정 Room Id를 가진 방의 모든 정보를 조회합니다.
- [X] 해당 방이 존재하지 않는 경우, 201 응답을 반환합니다.

8. 방 참가 API

- [X] 유저 정보는 RequestBody에 담아 요청합니다.
- [X] 다음과 같은 조건을 모두 만족하는 경우 참가가 가능합니다.
    - [X] User의 Status는 ACTIVE이다.
    - [X] User는 어떤 방에도 속해 있지 않다.
    - [X] Room의 정원이 미달이다.
    - [X] Room의 Status는 WAIT이다.
- [X] 조건을 만족하지 않는 경우, 201 응답을 반환합니다.
- [X] 해당하는 방 혹은 유저가 존재하지 않는 경우, 201 응답을 반환합니다.

9. 방 나가기 API

- [X] 유저 정보는 RequestBody에 담아 요청합니다.
- [X] 다음과 같은 조건을 모두 만족하는 경우 방 나가기가 가능합니다.
    - [X] User는 해당 방에 참가한 상태이다.
    - [X] Room의 Status는 WAIT이다.
- [X] 조건을 만족하지 않는 경우, 201 응답을 반환합니다.
- [X] 해당하는 방 혹은 유저가 존재하지 않는 경우, 201 응답을 반환합니다.
- [X] Host가 방을 나가게 될 경우, 방에 존재하는 모든 인원이 나가게 됩니다.
- [X] Host가 방을 나가게 될 경우, 방은 FINISH 상태로 변합니다.

10. 게임시작 API

- [X] 유저 정보는 RequestBody에 담아 요청합니다.
- [X] 다음과 같은 조건을 모두 만족하는 경우 게임 시작이 가능합니다.
    - [X] User는 해당 방에 참가한 상태이다.
    - [X] Room의 Status는 WAIT이다.
    - [X] Room의 정원이 모두 차있고, RED-BLUE 팀원 수가 정확히 반반이다.
    - [X] User는 해당 방의 Host이다.
- [X] 조건을 만족하지 않는 경우, 201 응답을 반환합니다.
- [X] 해당하는 방 혹은 유저가 존재하지 않는 경우, 201 응답을 반환합니다.
- [X] 게임 시작이 가능한 경우, 방의 상태를 PROGRESS로 변경한다.
- [X] 게임 시작이 된 방은 1분 뒤 종료 상태로 변경되며 참여자들은 모두 ACTIVE 상태가 된다.


11. 팀 변경 API

- [X] 유저 정보는 RequestBody에 담아 요청합니다.
- [X] 다음과 같은 조건을 모두 만족하는 경우 팀 변경이 가능합니다.
    - [X] User는 해당 방에 참가한 상태이다.
    - [X] Room의 Status는 WAIT이다.
    - [X] 반대 팀에는 빈 정원이 1자리 이상 있어야 한다.
- [X] 조건을 만족하지 않는 경우, 201 응답을 반환합니다.
- [X] 해당하는 방 혹은 유저가 존재하지 않는 경우, 201 응답을 반환합니다.
- [X] 게임 시작이 가능한 경우, 방의 상태를 PROGRESS로 변경한다.
- [X] 게임 시작이 된 방은 1분 뒤 종료 상태로 변경되며 참여자들은 모두 ACTIVE 상태가 된다.

### 💻 커밋 컨벤션

> [**AngularJS 커밋 컨벤션**](https://gist.github.com/stephenparish/9941e89d80e2bc58a153) 참고

| Type     | Description      |
|----------|------------------|
| feat     | 새로운 기능 추가        |
| fix      | 버그 수정            |
| docs     | 문서 변경            |
| style    | 코드 포맷 변경         |
| refactor | 코드 리팩토링          |
| test     | 테스트 추가 및 수정      |
| chore    | 빌드 작업 및 도구 관련 변경 |

### ❓ 구현 과정에서 고민했던 부분

1️⃣ 게임 시작이 된 방을 1분뒤 종료 상태로 변경하는 설계

(1) 요청 쓰레드에서 Thread.sleep() 을 사용하여 60초간 대기한다.

- 트랜잭션이 보장될 수 있음
- 응답 속도가 비정상적

(2) 새로운 쓰레드를 비동기적으로 실행하고, 요청 쓰레드의 블락을 피한다.

- Spring에서 제공하는 TaskScheduler 사용
- Java에서 제공하는 ScheduledExecutorService 사용

결과적으로 스프링에서 제공하는 TaskScheduler를 사용했습니다.

ScheduledExecutorService 만큼의 저수준의 스케줄링 제어의 필요성을 느끼지 못했고,
스프링 환경 위에선 빈 기반 TaskScheduler를 사용하는 것이 자연스럽다고 생각했습니다.

하지만 60초 간, 트랜잭션 외부에서 대기한다는 점에서 실제 환경이라면 Room, UserRoom에 Lock 을 고려할 것 같습니다.